#!/Users/thedrub/anaconda3/bin/python

# ----------------------------------------------------------------------
# Libraries
# ----------------------------------------------------------------------
import pandas as pd
import sys
import csv
import os
from optparse import OptionParser

# ----------------------------------------------------------------------
# My Libraries
# ----------------------------------------------------------------------
lib_path = os.environ['HOME'] + "/bin/lib"
sys.path.append(lib_path)
from format_str import StrCol

# ----------------------------------------------------------------------
# Files
# ----------------------------------------------------------------------
input_file_path = "gethrs_input.txt"
HOME = os.environ['HOME'] # Use the $HOME env variable
input_file_path = HOME + "/Sync/doc/journal/work/work_journal_file.txt"
output_file_path = "./gethrs_output.csv"

# ----------------------------------------------------------------------
# Constants
# ----------------------------------------------------------------------
prog_config = \
    {"name"     : os.path.basename(sys.argv[0]), \
    "maj_ver"   : "1", \
    "min_ver"   : "4", \
    }
prog_config["ver"] = prog_config["maj_ver"] + "." + prog_config["min_ver"]

TOKEN_COUNT_VER_4_dot_1 = 11  # The number of records in record ver 4.1
SEP_LN_LEN = 80               # Seperator line length
PLUS_LN_LEN = 50              # Leading line for an error

# ----------------------------------------------------------------------
# Intializations
# ----------------------------------------------------------------------
displayed_record_count = 0
line_counter = 0

# ----------------------------------------------------------------------
# Functions
# ----------------------------------------------------------------------

# --------------------------------------------------
def Usage():
# --------------------------------------------------
    print ("Way cool useage message")
    print (prog_config["name"])

# --------------------------------------------------
def Display_tokens(token_list):
# --------------------------------------------------
    i = 0
    for token in token_list:
        print ("[{0:2}] ... {1}".format(i, token))
        i += 1 

# --------------------------------------------------
def Display_Record(token_list):
# --------------------------------------------------
# Record version: 4.1
    line_length=80

    scale = "+123456789" * 7
    base_str = "." * 14 + " " * 60
    col_1  = 0
    data_1 = 15
    col_2  = 28
    data_2 = 35
    col_3  = 45
    data_3 = 52
    col_4  = 58
    data_4 = 65

    tok_line      = 0
    tok_rec_type  = 1
    tok_rec_ver   = 2
    tok_day       = 3
    tok_date      = 4
    tok_start     = 5
    tok_stop      = 6
    tok_duration  = 7
    tok_client    = 8
    tok_state     = 9
    tok_comment   = 10
    tok_remainder = 11

    # Line 1
    tmp_str = StrCol(base_str, " Client ", col_1)
    tmp_str = StrCol(tmp_str, token_list[tok_client], data_1)
    
    tmp_str = StrCol(tmp_str, "Line: ", col_3)
    tmp_str = StrCol(tmp_str, str(token_list[tok_line]), data_3)

    tmp_str = StrCol(tmp_str, "State: ", col_4)
    tmp_str = StrCol(tmp_str, str(token_list[tok_state]), data_4)
    print(tmp_str)

    # Line 2
    tmp_str = StrCol(base_str, " Date ", col_1)
    tmp_str = StrCol(tmp_str, token_list[tok_date], data_1)
    
    tmp_str = StrCol(tmp_str, "Day: ", col_2)
    tmp_str = StrCol(tmp_str, token_list[tok_day], data_2)
    print(tmp_str)

    # Line 3
    tmp_str = StrCol(base_str, " Duration ", col_1)
    tmp_str = StrCol(tmp_str, token_list[tok_duration], data_1)
    
    tmp_str = StrCol(tmp_str, "Start: ", col_2)
    tmp_str = StrCol(tmp_str, token_list[tok_start], data_2)
   
    tmp_str = StrCol(tmp_str, "Stop: ", col_3)
    tmp_str = StrCol(tmp_str, token_list[tok_stop], data_3)
    print(tmp_str)

    # If there is content, display the Comment field.
    if (token_list[tok_comment] != "") and (token_list[tok_comment] != "COMMENT"):
        tmp_str = StrCol(base_str, " Comment ", col_1)
        tmp_str = StrCol(tmp_str, token_list[tok_comment], data_1)
        print(tmp_str)

    # If there is content, display the Remainder field.
    if token_list[tok_remainder] != "":
        tmp_str = StrCol(base_str, " Remainder ", col_1)
        tmp_str = StrCol(tmp_str, token_list[tok_remainder], data_1)
        print(tmp_str)


# ----------------------------------------------------------------------
# Main MAIN main
# ----------------------------------------------------------------------

debug = True
debug = False

if debug:
    print ('++ Number of arguments ....... ', len(sys.argv))
    print ('++ Argument List:', str(sys.argv))

print ("")
print (prog_config["name"]  + " " + prog_config["ver"]) # Banner line.

parser = OptionParser()
parser.add_option("-a", action="store_true", dest="all", \
                 help = "display all records, regarless of state")
parser.add_option("-c", type="int", dest="rec_count", \
                 help = "display only this number of records")

(opts, args) = parser.parse_args()

#print("++ options ...") #debug
#print(opts) #debug

if opts.all :
    print("++ Option: Display all records.") #debug
if opts.rec_count != None: #debug
    print("++ Option: Display " + str(opts.rec_count) + " records.") #debug

#exit() #debug

column_names=["lineno",\
              "rec_type",\
              "rec_ver",\
              "day",\
              "date",\
              "start",\
              "end",\
              "duration",\
              "customer",\
              "rec_state",\
              "comment",\
              "remainder"]
df = pd.DataFrame(columns = column_names)

with open(input_file_path, 'r') as in_fd:
    for line in in_fd:
        line = line.rstrip('\r\n') # Strip the trailing EOL
        line_counter += 1

        tokens = line.split("::")
        token_count = len(tokens) # Count only the tokens from the input file.

        if (tokens[0] == "TIME") :

            # A TIME:: record was found.
            # Process token for record version 4.1 only
            # Deprecate earlier record versions with this new implementation

            # Record the input file line number in the record.
            tokens.insert(0, line_counter) 

            debug = False
            if debug == True :  #debug
                print ("+" * PLUS_LN_LEN)
                Display_tokens(tokens)

            record_ver  = tokens[1]
            record_state = tokens[9]

            if token_count != TOKEN_COUNT_VER_4_dot_1 :
                print ("+" * PLUS_LN_LEN)
                print ("++ Line " + str(tokens[0]) + ". Bad record. Token count mismatch.")
                print ("++ Expected " + str(TOKEN_COUNT_VER_4_dot_1) + " tokens, but " \
                        + str(token_count) + " tokens were found")\
                #print ("++ tokens: ", tokens) #debug
                Display_tokens(tokens[1:]) # Don't print the first token.

            else:
                if (record_state == "new") or (opts.all) :
                    displayed_record_count += 1
                    # Print records not yet recorded
                    print("-" * SEP_LN_LEN)

                    Display_Record(tokens)

                # Add the tokens list to the end of the dataframe
                df.loc[len(df)] = tokens


base_str = "." * 24 + " " * 50
data_col = 25

if displayed_record_count > 0:
    print("-" * SEP_LN_LEN)

    tmp_str = StrCol(base_str, " Records displayed ", 0)
    tmp_str = StrCol(tmp_str, str(displayed_record_count), data_col)
    print(tmp_str)
    
if len(df) == 0:
    tmp_str = StrCol(base_str, " No reords found.", 0)
    print(tmp_str)
else:
    tmp_str = StrCol(base_str, " Records recorded ", 0)
    tmp_str = StrCol(tmp_str, str(len(df)), data_col)
    print(tmp_str)

df.to_csv(output_file_path, index = False)

exit()

# ----------------------------------------------------------------------
# End END end
# ----------------------------------------------------------------------


'''
# ----------------------------------------------------------------------
# TODO
# ----------------------------------------------------------------------

- Default to writing to csv only records for the last 2 weeks

- Add a -a parameter, "all",  that writes to stdout records with any
  record_state and not just limited to the "a" state.

- Add a -c parameter, "count", that writes the count number of records to stdout.
  Combine with -a and "count" number of records will be displayed, regardless
  of the record state.

- Add a -w parameter, "csv count", that writes a fixed number of records
  to the csv file.  

# ----------------------------------------------------------------------
# History
# ----------------------------------------------------------------------

# --------------------------------------------------
# Ver: 1.4
# --------------------------------------------------
Record versions supported: 4.1

- Implement the "-a" option. Display records regardless of record state.
  - In the past, only records with state = "new" would be displayed on STDOUT
  - Display all records discovered
- Modify the STDOUT messages displayed
  - Add the record state
  - Modify the column value. Move column 3 to the left 5 spaces.

# --------------------------------------------------
# Ver: 1.3
# --------------------------------------------------
Record versions supported: 4.1

- Changed the "Bad record" error message.
- The line of "+" used for errors extended to 50.

# --------------------------------------------------
# Ver: 1.2
# --------------------------------------------------
Record versions supported: 4.1

- Used argparse() to parse 2 arguments
  - a  :: Display all records, not just rec state = "new"
  - -c count  :: Display only this number of records.
- Only parsed the paramters. Have not yet implemented the featues.

# --------------------------------------------------
# Ver: 1.1
# --------------------------------------------------
Record versions supported: 4.1

- Added Display_Record to display output that is substantially similar to
  the bash gethrs. Easier to read than printing a list.
- Wrote a library file format_str.py
  Includes SrtCol(str, str, int)
- Wrote routine to print TIME records found to STDOUT.


# --------------------------------------------------
# Ver: 1.0
# --------------------------------------------------
Record versions supported: 4.1

- Parses the input file for supported records
- Writes to stdout records with record_state = "a"
- Writes all TIME:: records to a csv file.
  - Input file name hard coded

'''
